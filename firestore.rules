rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isUserInChat(chatId) {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/chats/$(chatId)) &&
        request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
    }

    function isUsersSparkyChat(chatId) {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/sparkyChats/$(chatId)) &&
        request.auth.uid == get(/databases/$(database)/documents/sparkyChats/$(chatId)).data.userId;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function isTeacher() {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/teachers/$(request.auth.uid));
    }

    function isStudent() {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/students/$(request.auth.uid));
    }

    // Sparky Chat Messages rules - Updated with proper validation
    match /sparkyChatMessages/{messageId} {
      allow read: if isAuthenticated() && 
                 (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && 
                   request.resource.data.userId == request.auth.uid &&
                   request.resource.data.keys().hasAll(['text', 'sender', 'timestamp', 'userId']) &&
                   request.resource.data.text is string &&
                   request.resource.data.sender in ['user', 'bot'] &&
                   request.resource.data.timestamp is timestamp;
      allow update: if isAuthenticated() && 
                   resource.data.userId == request.auth.uid &&
                   (
                     // Only allow updating pinned status
                     request.resource.data.diff(resource.data).affectedKeys().hasOnly(['pinned']) &&
                     request.resource.data.pinned is bool
                   );
      allow delete: if isAuthenticated() && 
                   resource.data.userId == request.auth.uid;
    }

    // Chat History collection (for backward compatibility)
    match /chatHistory/{messageId} {
      allow read: if isAuthenticated() && 
                 (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && 
                   request.resource.data.userId == request.auth.uid &&
                   request.resource.data.keys().hasAll(['text', 'sender', 'timestamp', 'userId']) &&
                   request.resource.data.text is string &&
                   request.resource.data.sender in ['user', 'bot'] &&
                   request.resource.data.timestamp is timestamp;
      allow update: if isAuthenticated() && 
                   resource.data.userId == request.auth.uid &&
                   (
                     request.resource.data.diff(resource.data).affectedKeys().hasOnly(['pinned']) &&
                     request.resource.data.pinned is bool
                   );
      allow delete: if isAuthenticated() && 
                   resource.data.userId == request.auth.uid;
    }

    // Sparky Chat rules
    match /sparkyChats/{chatId} {
      allow read: if isAuthenticated() && request.auth.uid == resource.data.userId;
      allow create: if isAuthenticated() && request.auth.uid == request.resource.data.userId;
      allow update: if isAuthenticated() && request.auth.uid == resource.data.userId;
      allow delete: if isAuthenticated() && request.auth.uid == resource.data.userId;
    }

    // Sparky Messages rules
    match /sparkyMessages/{messageId} {
      allow read: if isAuthenticated() && isUsersSparkyChat(resource.data.chatId);
      allow create: if isAuthenticated() && isUsersSparkyChat(request.resource.data.chatId);
      allow update: if isAuthenticated() && isUsersSparkyChat(resource.data.chatId);
      allow delete: if isAuthenticated() && isUsersSparkyChat(resource.data.chatId);
    }

    // Question history rules
    match /questionHistory/{docId} {
      allow read: if isAuthenticated() && 
                 (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && 
                   request.resource.data.userId == request.auth.uid &&
                   (
                     // Validate required fields
                     request.resource.data.question is string &&
                     request.resource.data.subject is string &&
                     request.resource.data.difficulty is string &&
                     request.resource.data.timestamp is timestamp &&
                     request.resource.data.isAnswered is bool &&
                     // Tags must be an array of strings if present
                     (!('tags' in request.resource.data) || request.resource.data.tags is list) &&
                     // generatedBy must be string if present
                     (!('generatedBy' in request.resource.data) || request.resource.data.generatedBy is string)
                   );
      allow delete: if isAuthenticated() && 
                   resource.data.userId == request.auth.uid;
      // Questions are immutable once created
      allow update: if false;
    }

    // Keep open access for assignments (as requested)
    match /assignments/{assignment} {
      allow read: if true;
      allow create: if isTeacher();
      allow update: if isAuthenticated() && (
        isTeacher() || // Teachers can update everything
        (isStudent() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['totalSubmissions'])) // Students can only update totalSubmissions
      );
      allow delete: if isTeacher();
    }

    // Student-specific rules
    match /students/{studentId} {
      allow read: if isAuthenticated();
      allow write: if isAuthenticated() && request.auth.uid == studentId;
    }

    // Teacher-specific rules
    match /teachers/{teacherId} {
      allow read: if isAuthenticated();
      allow write: if isAuthenticated() && request.auth.uid == teacherId;
    }

    // User profiles and settings
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow write: if isAuthenticated() && request.auth.uid == userId;
    }

    // Optional: Shared resources that both can access
    match /resources/{resourceId} {
      allow read: if isAuthenticated();
      allow write: if false; // Or your custom logic for who can write
    }

    // Questions collection
    match /questions/{questionId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Chat messages
    match /messages/{messageId} {
      allow read: if isAuthenticated() && 
                 (resource == null || isUserInChat(resource.data.chatId));
      allow create: if isAuthenticated() && 
                   isUserInChat(request.resource.data.chatId) && 
                   request.auth.uid == request.resource.data.sender;
      allow update: if isAuthenticated() && 
                   isUserInChat(resource.data.chatId) &&
                   (request.auth.uid == resource.data.sender || 
                    request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isRead']));
      allow delete: if isAuthenticated() && 
                   isUserInChat(resource.data.chatId) && 
                   request.auth.uid == resource.data.sender;
    }

    // Chat rooms
    match /chats/{chatId} {
      allow read: if isAuthenticated() && request.auth.uid in resource.data.participants;
      allow create: if isAuthenticated() && request.auth.uid in request.resource.data.participants;
      allow update: if isAuthenticated() && request.auth.uid in resource.data.participants;
      allow delete: if isAuthenticated() && request.auth.uid in resource.data.participants;
    }

    // Connections collection rules
    match /connections/{connectionId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && 
                    request.resource.data.senderId == request.auth.uid &&
                    request.resource.data.status == 'pending';
      allow update: if isAuthenticated() && 
                    (resource.data.receiverId == request.auth.uid || 
                     resource.data.senderId == request.auth.uid);
      allow delete: if isAuthenticated() && 
                    (resource.data.senderId == request.auth.uid || 
                     resource.data.receiverId == request.auth.uid);
    }

    // Assignments collection
    match /assignments/{assignmentId} {
      allow read: if isAuthenticated();
      allow create: if isTeacher();
      allow update: if isAuthenticated() && (
        (isTeacher() && resource.data.teacherId == request.auth.uid) || // Teachers can update their own assignments
        (isStudent() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['totalSubmissions'])) // Students can only update totalSubmissions
      );
      allow delete: if isTeacher() && resource.data.teacherId == request.auth.uid;
    }

    // Submissions collection
    match /submissions/{submissionId} {
      allow read: if isAuthenticated() && (
        isTeacher() || // Teachers can read all submissions
        (isStudent() && (resource == null || resource.data.studentId == request.auth.uid)) // Students can read their own submissions
      );
      allow create: if isAuthenticated() && 
        isStudent() && // Only students can create submissions
        request.resource.data.studentId == request.auth.uid && // Can only submit for themselves
        request.resource.data.keys().hasAll(['assignmentId', 'studentId', 'studentName', 'fileUrl', 'fileName', 'submittedAt', 'status']); // Required fields
      allow update: if isAuthenticated() && (
        isTeacher() || // Teachers can update any submission (for grading)
        (isStudent() && 
         resource.data.studentId == request.auth.uid && // Student can only update their own submissions
         request.resource.data.studentId == request.auth.uid) // Cannot change the studentId
      );
      allow delete: if false; // No one can delete submissions
    }
  }
}

service firebase.storage {
  match /b/{bucket}/o {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isUserInChat(chatId) {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/chats/$(chatId)) &&
             request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
    }

    // Profile pictures - specific rules
    match /profile-pictures/{userId}/{allPaths=**} {
      allow read: if isAuthenticated();  // Any authenticated user can view profile pictures
      allow write: if isAuthenticated() && request.auth.uid == userId;  // Only user can upload their own picture
    }

    // Chat attachments and files
    match /chat/{chatId}/{allPaths=**} {
      allow read: if isUserInChat(chatId);
      allow write: if isUserInChat(chatId) && 
                   request.resource.size < 10 * 1024 * 1024 &&  // 10MB file size limit
                   request.resource.contentType.matches('image/.*|video/.*|application/pdf');  // Restrict file types
    }

    // Assignment files
    match /assignments/{assignmentId}/{allPaths=**} {
      allow read: if isAuthenticated();
      allow write: if isAuthenticated() && 
                   request.resource.size < 20 * 1024 * 1024;  // 20MB file size limit
    }

    // Allow read access to all authenticated users
    match /{allPaths=**} {
      allow read: if isAuthenticated();
    }

    // Allow write access only to user's own directory
    match /users/{userId}/{allPaths=**} {
      allow write: if isAuthenticated() && request.auth.uid == userId;
    }

    // Submission files
    match /submissions/{assignmentId}/{studentId}/{fileName} {
      allow read: if isAuthenticated() && (
        isTeacher() || // Teachers can read all submissions
        request.auth.uid == studentId // Students can read their own submissions
      );
      allow write: if isAuthenticated() && 
        request.auth.uid == studentId && // Students can only write to their own folder
        request.resource.size < 50 * 1024 * 1024; // 50MB file size limit
    }
  }
} 